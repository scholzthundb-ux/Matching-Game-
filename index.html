<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vokabel-Matching</title>
  <style>
    :root{
      --bg:#ffffff;
      --card:#f2e6d5;
      --text:#111;
      --muted:#666;
      --border:#ddd;
      --shadow: 0 2px 10px rgba(0,0,0,.06);
      --ok:#1f7a1f;
      --bad:#b42318;
      --accent:#0b57d0;
    }
    *{box-sizing:border-box;}
    html,body{height:100%;}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background:var(--bg);
      color:var(--text);
      overflow-x:hidden;
      overscroll-behavior: none;
      touch-action: manipulation;
    }
    .app{min-height:100vh;display:flex;flex-direction:column;}
    header{
      padding:14px 16px;border-bottom:1px solid var(--border);
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      position:sticky;top:0;background:var(--bg);z-index:10;
    }
    header h1{font-size:16px;margin:0;font-weight:900;}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .mini{font-size:12px;color:var(--muted);font-weight:900;}
    button{
      border:1px solid var(--border);
      background:#fff;border-radius:10px;padding:10px 12px;font-weight:800;cursor:pointer;
    }
    button.primary{background:var(--accent);border-color:var(--accent);color:#fff;}
    button.danger{border-color:#f1b4b0;background:#fff;color:var(--bad);}
    button:disabled{opacity:.5;cursor:not-allowed;}
    select{
      border:1px solid var(--border);
      background:#fff;border-radius:10px;padding:10px 12px;font-weight:800;
    }
    input[type="checkbox"]{transform:scale(1.05);}
    .wrap{padding:16px;max-width:1200px;width:100%;margin:0 auto;}
    .panel{border:1px solid var(--border);border-radius:14px;padding:14px;box-shadow:var(--shadow);background:#fff;}
    textarea,input{
      width:100%;border:1px solid var(--border);border-radius:12px;padding:10px 12px;font-size:14px;outline:none;
    }
    textarea{min-height:170px;resize:vertical;}
    .muted{color:var(--muted);font-size:13px;line-height:1.35;}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#f6f6f6;border:1px solid var(--border);font-size:12px;color:var(--muted);font-weight:900;}
    .grid2{display:grid;grid-template-columns:1.15fr .85fr;gap:14px;}
    @media (max-width:900px){.grid2{grid-template-columns:1fr;}}

    .listTable{width:100%;border-collapse:collapse;font-size:14px;}
    .listTable th,.listTable td{border-bottom:1px solid var(--border);padding:10px 8px;vertical-align:top;}
    .listTable th{text-align:left;font-size:13px;color:var(--muted);font-weight:1000;}
    .starsBtn{
      border:1px solid var(--border);
      background:#fff;border-radius:10px;padding:8px 10px;font-weight:1000;cursor:pointer;
      min-width:70px;text-align:center;
    }
    .previewBox{
      margin-top:12px;border:1px solid var(--border);border-radius:14px;overflow:auto;max-height:360px;
    }
    .previewHeader{
      padding:10px 12px;border-bottom:1px solid var(--border);
      display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;
      background:#fff;position:sticky;top:0;z-index:2;
    }
    .hint{font-size:12px;color:var(--muted);font-weight:900;}

    /* Game */
    .game{flex:1;display:none;padding:10px;}
    .gameTop{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:10px 6px;flex-wrap:wrap;}
    .stats{font-size:14px;color:var(--muted);font-weight:900;}
    .msg{font-size:14px;font-weight:1000;min-height:18px;}
    .msg.ok{color:var(--ok);} .msg.bad{color:var(--bad);}

    .board{
      flex:1;
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
      height: calc(100vh - 175px);
      padding:6px;
      overflow:hidden;
      touch-action: pan-y;
      overscroll-behavior-x: none;
    }
    @media (max-width:700px){.board{gap:10px;height: calc(100vh - 215px);}}

    .col{
      border:1px solid var(--border);
      border-radius:16px;
      padding:10px;
      background:#fff;
      box-shadow:var(--shadow);
      overflow:hidden;
      min-width:0;
    }
    .colTitle{font-weight:1000;margin:0 0 10px 0;font-size:14px;}

    .cards{
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow-y:auto;
      overflow-x:hidden;
      max-height: calc(100% - 24px);
      touch-action: pan-y;
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
    }

    .card{
      background:var(--card);
      border:1px solid rgba(0,0,0,.06);
      border-radius:14px;
      padding:12px 12px;
      box-shadow:0 1px 6px rgba(0,0,0,.05);
      cursor:pointer;
      user-select:none;
      transition:transform .05s ease, outline-color .1s ease;
      outline:3px solid transparent;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
      touch-action: manipulation;
    }
    .card:active{transform:scale(.99);}
    .card.selected{outline-color:var(--accent);}
    .card.correctFlash{outline-color:var(--ok);}
    .card.wrongFlash{outline-color:var(--bad);}
    .leftText{font-weight:1000;}
    .rightText{font-weight:1000;} /* Antworten fett */
    .starLine{margin-top:5px;font-size:12px;color:var(--muted);font-weight:900;}
    .footerBar{display:flex;gap:10px;justify-content:flex-end;padding:10px 6px 14px 6px;flex-wrap:wrap;}
  </style>
</head>
<body>
<div class="app">

  <header>
    <h1>Vokabel-Matching</h1>
    <div class="row">
      <button id="btnShowEditor">Eingabe / Liste</button>
      <button class="primary" id="btnStart">Üben starten</button>
      <button id="btnFullscreen">Vollbild</button>
    </div>
  </header>

  <!-- EDITOR -->
  <div class="wrap" id="editorScreen">
    <div class="grid2">

      <div class="panel">
        <h2 style="margin:0 0 10px 0; font-size:16px;">Vokabelliste importieren</h2>

        <p class="muted" style="margin-top:0;">
          <b>Import-Format:</b> <span class="pill">Vokabel;Übersetzung</span><br>
          Optional am Zeilenende: <span class="pill">*</span> / <span class="pill">**</span> / <span class="pill">***</span>
          oder <span class="pill">[1]</span>/<span class="pill">[2]</span>/<span class="pill">[3]</span>
        </p>

        <textarea id="bulkInput" placeholder="das Boot;la barca&#10;die Schubkarre;la carretilla **&#10;das Pony;el poni [3]"></textarea>

        <div class="row" style="margin-top:10px; align-items:center;">
          <span class="mini">Ganze Liste als Favorit:</span>
          <select id="bulkStar">
            <option value="0">—</option>
            <option value="1">★</option>
            <option value="2">★★</option>
            <option value="3">★★★</option>
          </select>

          <label class="row" style="gap:8px;">
            <input type="checkbox" id="keepLineStars" checked>
            <span class="mini">Zeilen-Sterne nicht überschreiben</span>
          </label>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnAnalyze">Liste analysieren (Vorschau)</button>
          <button class="primary" id="btnImport">Importieren / Aktualisieren</button>
          <button class="danger" id="btnEmptyList">Liste leeren</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnExport">Backup exportieren (TXT)</button>
          <input type="file" id="fileImport" accept=".txt,text/plain" style="display:none;">
          <button id="btnImportTxt">TXT laden</button>
        </div>

        <p class="muted" id="importInfo" style="margin:10px 0 0 0;"></p>

        <div class="previewBox" id="previewBox" style="display:none;">
          <div class="previewHeader">
            <div class="row">
              <span class="pill" id="previewCount">0 Zeilen</span>
              <span class="hint">Sterne anklicken: 0→1→2→3→0</span>
            </div>
            <div class="row">
              <span class="mini">Vorschau: alle setzen</span>
              <button id="setAll0">—</button>
              <button id="setAll1">★</button>
              <button id="setAll2">★★</button>
              <button id="setAll3">★★★</button>
            </div>
          </div>
          <table class="listTable" style="margin:0;">
            <thead>
              <tr><th>Vokabel</th><th>Übersetzung</th><th>Favorit</th></tr>
            </thead>
            <tbody id="previewBody"></tbody>
          </table>
        </div>
      </div>

      <div class="panel">
        <h2 style="margin:0 0 10px 0; font-size:16px;">Einzelnen Eintrag hinzufügen</h2>

        <div class="row" style="width:100%;">
          <div style="flex:1; min-width:220px;">
            <input id="oneLeft" placeholder="Vokabel (links)" />
          </div>
          <div style="flex:1; min-width:220px;">
            <input id="oneRight" placeholder="Übersetzung (rechts)" />
          </div>
        </div>

        <div class="row" style="margin-top:10px; align-items:center;">
          <span class="mini">Sterne:</span>
          <select id="oneStar">
            <option value="0">keine</option>
            <option value="1">★</option>
            <option value="2">★★</option>
            <option value="3">★★★</option>
          </select>
          <button class="primary" id="btnAddOne">Hinzufügen</button>
        </div>

        <hr style="border:none; border-top:1px solid var(--border); margin:14px 0;">

        <h2 style="margin:0 0 10px 0; font-size:16px;">Aktuelle Liste</h2>

        <div style="max-height:470px; overflow:auto; border:1px solid var(--border); border-radius:14px;">
          <table class="listTable" id="listTable">
            <thead>
              <tr><th>Vokabel</th><th>Übersetzung</th><th>Favorit</th><th></th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <p class="muted" style="margin:10px 0 0 0;" id="countInfo"></p>
      </div>

    </div>
  </div>

  <!-- GAME -->
  <div class="game" id="gameScreen">
    <div class="gameTop">
      <div class="row" style="gap:10px;">
        <div class="stats" id="stats"></div>
        <div class="row" style="gap:8px; align-items:center;">
          <span class="mini">Üben:</span>
          <select id="practiceFilter">
            <option value="all">Alle</option>
            <option value="1">Nur ★</option>
            <option value="2">Nur ★★</option>
            <option value="3">Nur ★★★</option>
          </select>
        </div>
      </div>
      <div class="msg" id="msg"></div>
    </div>

    <div class="board">
      <div class="col">
        <div class="colTitle">Frage (links)</div>
        <div class="cards" id="leftCol"></div>
      </div>
      <div class="col">
        <div class="colTitle">Antwort (rechts)</div>
        <div class="cards" id="rightCol"></div>
      </div>
    </div>

    <div class="footerBar">
      <button id="btnRestart">Neuer Durchlauf</button>
      <button class="danger" id="btnStop">Zurück zur Eingabe</button>
    </div>
  </div>

</div>

<script>
/* =========================
   CONFIG
========================= */
const STORAGE_KEY = "vokabel_matching_semikolon_v5";
const MAX_SLOTS = 6;
const TARGET_CORRECT = 100;
const POOL_SIZE = 50;

/* =========================
   HELPERS
========================= */
function clampStar(x){
  const n = Number(x);
  if(!Number.isFinite(n)) return 0;
  return Math.max(0, Math.min(3, Math.round(n)));
}
function normalizeText(s){
  return String(s).replace(/\s+/g, " ").trim();
}
function starsToText(n){
  n = clampStar(n);
  return n===0 ? "" : "★".repeat(n);
}
function starsToExport(n){
  n = clampStar(n);
  return n===0 ? "" : " " + "*".repeat(n);
}
function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}

/* =========================
   STORAGE
========================= */
function loadPairs(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return [];
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return [];
    return arr
      .filter(p => p && typeof p.left==="string" && typeof p.right==="string")
      .map(p => ({ left:p.left, right:p.right, star: clampStar(p.star) }));
  }catch{
    return [];
  }
}
function savePairs(pairs){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(pairs));
}
function toTxt(pairs){
  return pairs.map(p => `${p.left};${p.right}${starsToExport(p.star)}`).join("\n");
}

/* =========================
   IMPORT (nur Semikolon)
========================= */
function parseStarSuffix(line){
  let t = line.trim();

  const mNum = t.match(/\s*\[(\d)\]\s*$/);
  if(mNum){
    const star = clampStar(mNum[1]);
    t = t.replace(/\s*\[(\d)\]\s*$/, "").trim();
    return { text: t, star };
  }

  const mBracketStars = t.match(/\s*\[(\*{1,3})\]\s*$/);
  if(mBracketStars){
    const star = clampStar(mBracketStars[1].length);
    t = t.replace(/\s*\[(\*{1,3})\]\s*$/, "").trim();
    return { text: t, star };
  }

  const mStars = t.match(/\s(\*{1,3})\s*$/);
  if(mStars){
    const star = clampStar(mStars[1].length);
    t = t.replace(/\s(\*{1,3})\s*$/, "").trim();
    return { text: t, star };
  }

  return { text: t, star: 0 };
}

function splitPairSemicolon(text){
  const idx = text.indexOf(";");
  if(idx === -1) return null;

  const left = normalizeText(text.slice(0, idx));
  const right = normalizeText(text.slice(idx + 1));
  if(!left || !right) return null;

  return { left, right };
}

function parsePairsFromText(text){
  const lines = String(text).split(/\r?\n/);
  const out = [];
  let invalid = 0;

  for(const rawLine of lines){
    const line = rawLine.trim();
    if(!line) continue;

    const { text: noStars, star } = parseStarSuffix(line);
    const split = splitPairSemicolon(noStars);
    if(!split){ invalid++; continue; }

    out.push({ left: split.left, right: split.right, star: clampStar(star) });
  }
  return { out, invalid };
}

function applyBulkStars(list){
  const bulkStar = clampStar(document.getElementById("bulkStar")?.value ?? 0);
  const keep = !!document.getElementById("keepLineStars")?.checked;

  if(bulkStar === 0){
    return list.map(p => ({...p, star: clampStar(p.star)}));
  }
  return list.map(p => {
    const lineStar = clampStar(p.star);
    if(keep && lineStar > 0) return {...p, star: lineStar};
    return {...p, star: bulkStar};
  });
}

/* =========================
   UI / STATE
========================= */
const editorScreen = document.getElementById("editorScreen");
const gameScreen   = document.getElementById("gameScreen");

const bulkInput   = document.getElementById("bulkInput");
const importInfo  = document.getElementById("importInfo");
const countInfo   = document.getElementById("countInfo");

const previewBox   = document.getElementById("previewBox");
const previewBody  = document.getElementById("previewBody");
const previewCount = document.getElementById("previewCount");

const listTableBody = document.querySelector("#listTable tbody");

const leftCol = document.getElementById("leftCol");
const rightCol = document.getElementById("rightCol");
const stats = document.getElementById("stats");
const msg = document.getElementById("msg");
const practiceFilter = document.getElementById("practiceFilter");

let pairs = loadPairs();
let previewEntries = [];

function setImportInfo(text){ importInfo.textContent = text; }

function updateCounts(){
  const total = pairs.length;
  const s1 = pairs.filter(p=>p.star===1).length;
  const s2 = pairs.filter(p=>p.star===2).length;
  const s3 = pairs.filter(p=>p.star===3).length;
  countInfo.textContent = `In der App: ${total} Paare. Favoriten: ★ ${s1}, ★★ ${s2}, ★★★ ${s3}.`;
}

function renderList(){
  listTableBody.innerHTML = "";
  pairs.forEach((p, i) => {
    const tr = document.createElement("tr");

    const tdL = document.createElement("td");
    tdL.textContent = p.left;

    const tdR = document.createElement("td");
    tdR.textContent = p.right;

    const tdS = document.createElement("td");
    const starBtn = document.createElement("button");
    starBtn.className = "starsBtn";
    starBtn.textContent = (p.star===0) ? "—" : starsToText(p.star);
    starBtn.title = "Klicken: 0 → 1 → 2 → 3 → 0";
    starBtn.addEventListener("click", () => {
      pairs[i].star = (pairs[i].star + 1) % 4;
      savePairs(pairs);
      renderList();
      updateCounts();
    });
    tdS.appendChild(starBtn);

    const tdB = document.createElement("td");
    const del = document.createElement("button");
    del.className = "danger";
    del.textContent = "Löschen";
    del.addEventListener("click", () => {
      pairs.splice(i,1);
      savePairs(pairs);
      renderList();
      updateCounts();
      setImportInfo(`Gelöscht. In der App: ${pairs.length}.`);
    });
    tdB.appendChild(del);

    tr.appendChild(tdL);
    tr.appendChild(tdR);
    tr.appendChild(tdS);
    tr.appendChild(tdB);
    listTableBody.appendChild(tr);
  });
}

function renderPreview(){
  previewBody.innerHTML = "";
  previewCount.textContent = `${previewEntries.length} Zeilen`;
  previewBox.style.display = previewEntries.length ? "block" : "none";

  previewEntries.forEach((p, idx) => {
    const tr = document.createElement("tr");

    const tdL = document.createElement("td");
    tdL.textContent = p.left;

    const tdR = document.createElement("td");
    tdR.textContent = p.right;

    const tdS = document.createElement("td");
    const starBtn = document.createElement("button");
    starBtn.className = "starsBtn";
    starBtn.textContent = (p.star===0) ? "—" : starsToText(p.star);
    starBtn.title = "Klicken: 0 → 1 → 2 → 3 → 0";
    starBtn.addEventListener("click", () => {
      previewEntries[idx].star = (previewEntries[idx].star + 1) % 4;
      renderPreview();
    });
    tdS.appendChild(starBtn);

    tr.appendChild(tdL);
    tr.appendChild(tdR);
    tr.appendChild(tdS);
    previewBody.appendChild(tr);
  });
}

function setAllPreviewStars(n){
  n = clampStar(n);
  document.getElementById("bulkStar").value = String(n);
  document.getElementById("keepLineStars").checked = false;
  previewEntries = previewEntries.map(p => ({...p, star:n}));
  renderPreview();
}

/* =========================
   EDITOR EVENTS
========================= */
document.getElementById("btnAnalyze").addEventListener("click", () => {
  const { out, invalid } = parsePairsFromText(bulkInput.value);
  previewEntries = applyBulkStars(out);

  if(previewEntries.length === 0){
    setImportInfo("Keine gültigen Zeilen gefunden. Format muss sein: Vokabel;Übersetzung");
  }else{
    setImportInfo(`Vorschau ok: ${previewEntries.length} gültige Zeilen. Ungültig: ${invalid}.`);
  }
  renderPreview();
});

document.getElementById("setAll0").addEventListener("click", ()=>setAllPreviewStars(0));
document.getElementById("setAll1").addEventListener("click", ()=>setAllPreviewStars(1));
document.getElementById("setAll2").addEventListener("click", ()=>setAllPreviewStars(2));
document.getElementById("setAll3").addEventListener("click", ()=>setAllPreviewStars(3));

document.getElementById("btnImport").addEventListener("click", () => {
  const before = pairs.length;

  const { out, invalid } = parsePairsFromText(bulkInput.value);
  const parsed = applyBulkStars(out);

  if(parsed.length === 0){
    setImportInfo("Import abgebrochen: keine gültigen Zeilen. Format: Vokabel;Übersetzung");
    return;
  }

  const seen = new Set();
  const uniqueParsed = [];
  for(const p of parsed){
    const key = `${p.left}|||${p.right}`;
    if(seen.has(key)) continue;
    seen.add(key);
    uniqueParsed.push(p);
  }

  const map = new Map();
  pairs.forEach((p, idx) => map.set(`${p.left}|||${p.right}`, idx));

  let added = 0;
  let updatedStars = 0;

  for(const p of uniqueParsed){
    const key = `${p.left}|||${p.right}`;
    if(map.has(key)){
      const idx = map.get(key);
      if(pairs[idx].star !== clampStar(p.star)){
        pairs[idx].star = clampStar(p.star);
        updatedStars++;
      }
    }else{
      pairs.push({left:p.left, right:p.right, star: clampStar(p.star)});
      map.set(key, pairs.length-1);
      added++;
    }
  }

  savePairs(pairs);
  renderList();
  updateCounts();

  const after = pairs.length;

  setImportInfo(
    `Import fertig. ` +
    `Gültig erkannt: ${out.length}, ` +
    `ungültig: ${invalid}. ` +
    `Einzigartig: ${uniqueParsed.length}. ` +
    `Neu importiert: ${added}. ` +
    `Sterne geändert: ${updatedStars}. ` +
    `In der App: ${after} (vorher ${before}).`
  );

  previewEntries = uniqueParsed;
  renderPreview();
});

/* >>> Liste leeren = nur Eingabekiste leeren, NICHT gespeicherte Paare */
document.getElementById("btnEmptyList").addEventListener("click", () => {
  bulkInput.value = "";
  previewEntries = [];
  renderPreview();
  setImportInfo("Eingabefeld geleert. Gespeicherte Vokabeln bleiben unverändert.");
});

document.getElementById("btnAddOne").addEventListener("click", () => {
  const l = normalizeText(document.getElementById("oneLeft").value);
  const r = normalizeText(document.getElementById("oneRight").value);
  const s = clampStar(document.getElementById("oneStar").value);

  if(!l || !r){
    setImportInfo("Bitte beide Felder ausfüllen.");
    return;
  }

  const key = `${l}|||${r}`;
  const existing = pairs.find(p => `${p.left}|||${p.right}` === key);
  if(existing){
    existing.star = s;
    savePairs(pairs);
    renderList();
    updateCounts();
    setImportInfo("Eintrag existierte schon – Sterne aktualisiert.");
    return;
  }

  pairs.push({left:l, right:r, star:s});
  savePairs(pairs);

  document.getElementById("oneLeft").value = "";
  document.getElementById("oneRight").value = "";
  document.getElementById("oneStar").value = "0";

  renderList();
  updateCounts();
  setImportInfo(`Eintrag hinzugefügt. In der App: ${pairs.length}.`);
});

document.getElementById("btnExport").addEventListener("click", () => {
  const blob = new Blob([toTxt(pairs)], {type:"text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "vokabel-backup.txt";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

const fileImport = document.getElementById("fileImport");
document.getElementById("btnImportTxt").addEventListener("click", () => fileImport.click());
fileImport.addEventListener("change", async (e) => {
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const text = await f.text();
  bulkInput.value = text;
  previewEntries = [];
  renderPreview();
  setImportInfo("TXT geladen. Jetzt „Importieren / Aktualisieren“ drücken.");
  fileImport.value = "";
});

document.getElementById("btnShowEditor").addEventListener("click", () => showEditor());

/* =========================
   GAME LOGIC
========================= */
let session = null;

function setMessage(text, kind){
  msg.textContent = text || "";
  msg.className = "msg" + (kind ? " " + kind : "");
}

function getPracticePool(){
  const filter = practiceFilter.value;
  if(filter === "all") return pairs.slice();
  const n = clampStar(filter);
  return pairs.filter(p => p.star === n);
}

function newSession(){
  const pool = getPracticePool();
  const snapshot = pool.map((p, idx) => ({...p, id: idx}));
  const ids = snapshot.map(p => p.id);
  shuffle(ids);

  const uniqueCount = Math.min(POOL_SIZE, snapshot.length);
  const base = ids.slice(0, uniqueCount);

  return {
    target: TARGET_CORRECT,
    correct: 0,
    pairsSnapshot: snapshot,
    baseIds: base.slice(),
    queue: [],
    activeLeft: [],
    activeRight: [],
    selectedLeftSlotId: null
  };
}

function ensureQueue(){
  if(session.queue.length === 0 && session.correct < session.target){
    const block = session.baseIds.slice();
    shuffle(block);
    session.queue.push(...block);
  }
}

function renderStats(){
  if(!session) return;
  stats.textContent = `Richtig: ${session.correct} / ${session.target} • Pool: ${session.baseIds.length} • Aktiv: ${session.activeLeft.length} / ${MAX_SLOTS}`;
}

function renderBoard(){
  leftCol.innerHTML = "";
  rightCol.innerHTML = "";

  for(const item of session.activeLeft){
    const div = document.createElement("div");
    div.className = "card";
    div.dataset.slotId = item.slotId;
    div.innerHTML = `
      <div class="leftText">${escapeHtml(item.text)}</div>
      <div class="starLine">${item.star ? starsToText(item.star) : ""}</div>
    `;
    if(session.selectedLeftSlotId === item.slotId) div.classList.add("selected");
    div.addEventListener("click", () => onLeftClick(item.slotId));
    leftCol.appendChild(div);
  }

  for(const item of session.activeRight){
    const div = document.createElement("div");
    div.className = "card";
    div.dataset.slotId = item.slotId;
    div.innerHTML = `
      <div class="rightText">${escapeHtml(item.text)}</div>
      <div class="starLine">${item.star ? starsToText(item.star) : ""}</div>
    `;
    div.addEventListener("click", () => onRightClick(item.slotId));
    rightCol.appendChild(div);
  }

  renderStats();
}

function flash(slotId, side, cls){
  const root = side === "left" ? leftCol : rightCol;
  const el = root.querySelector(`[data-slot-id="${CSS.escape(slotId)}"]`);
  if(!el) return;
  el.classList.add(cls);
  setTimeout(()=> el.classList.remove(cls), 260);
}

function removePairBySlot(slotId){
  session.activeLeft  = session.activeLeft.filter(x => x.slotId !== slotId);
  session.activeRight = session.activeRight.filter(x => x.slotId !== slotId);
}

function fillBoard(){
  while(session.activeLeft.length < MAX_SLOTS && session.correct < session.target){
    ensureQueue();
    if(session.queue.length === 0) break;

    const pairId = session.queue.shift();
    if(session.activeLeft.some(x => x.pairId === pairId)) continue;

    const pair = session.pairsSnapshot.find(p => p.id === pairId);
    if(!pair) continue;

    const slotId = (crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2));
    session.activeLeft.push({slotId, pairId, text: pair.left, star: pair.star});
    session.activeRight.push({slotId, pairId, text: pair.right, star: pair.star});
  }

  shuffle(session.activeLeft);
  shuffle(session.activeRight);
  renderBoard();
}

function onLeftClick(slotId){
  session.selectedLeftSlotId = slotId;
  setMessage("Jetzt rechts die passende Antwort tippen.", "");
  renderBoard();
}

function onRightClick(slotId){
  if(!session.selectedLeftSlotId){
    setMessage("Erst links eine Frage auswählen.", "");
    return;
  }

  const leftSlot = session.selectedLeftSlotId;
  const leftItem = session.activeLeft.find(x => x.slotId === leftSlot);
  const rightItem = session.activeRight.find(x => x.slotId === slotId);

  if(!leftItem || !rightItem){
    session.selectedLeftSlotId = null;
    renderBoard();
    return;
  }

  const isMatch = leftItem.pairId === rightItem.pairId;

  if(isMatch){
    flash(leftSlot, "left", "correctFlash");
    flash(slotId, "right", "correctFlash");
    setMessage("Richtig ✓", "ok");

    removePairBySlot(leftSlot);
    session.selectedLeftSlotId = null;

    session.correct += 1;

    if(session.correct >= session.target){
      renderBoard();
      setMessage("Durchlauf fertig. „Neuer Durchlauf“ startet neu gemischt (neuer Pool).", "ok");
      return;
    }

    fillBoard();
  }else{
    flash(leftSlot, "left", "wrongFlash");
    flash(slotId, "right", "wrongFlash");
    setMessage("Falsch ✗ — kommt im selben Durchlauf später nochmal.", "bad");

    session.queue.push(leftItem.pairId);

    session.selectedLeftSlotId = null;
    renderBoard();
  }
}

/* =========================
   NAVIGATION
========================= */
function showEditor(){
  gameScreen.style.display = "none";
  editorScreen.style.display = "block";

  pairs = loadPairs();
  bulkInput.value = toTxt(pairs);

  previewEntries = [];
  renderPreview();

  renderList();
  updateCounts();

  setMessage("", "");
  setImportInfo(`In der App: ${pairs.length}.`);
}
function showGame(){
  editorScreen.style.display = "none";
  gameScreen.style.display = "block";
  setMessage("", "");
}

document.getElementById("btnStart").addEventListener("click", () => {
  pairs = loadPairs();
  const pool = getPracticePool();

  if(pool.length < MAX_SLOTS){
    showEditor();
    setImportInfo(`Für ${MAX_SLOTS}+${MAX_SLOTS} Karten brauchst du in der gewählten Auswahl mindestens ${MAX_SLOTS} Paare.`);
    return;
  }

  session = newSession();
  showGame();
  fillBoard();
});

document.getElementById("btnRestart").addEventListener("click", () => {
  pairs = loadPairs();
  const pool = getPracticePool();

  if(pool.length < MAX_SLOTS){
    setMessage(`Zu wenige Paare in dieser Auswahl (mind. ${MAX_SLOTS}).`, "bad");
    return;
  }

  session = newSession();
  setMessage("Neuer Durchlauf gestartet (neuer 50er-Pool).", "ok");
  fillBoard();
});

document.getElementById("btnStop").addEventListener("click", () => {
  session = null;
  showEditor();
});

document.getElementById("btnFullscreen").addEventListener("click", async () => {
  try{
    if(!document.fullscreenElement){
      await document.documentElement.requestFullscreen();
    }else{
      await document.exitFullscreen();
    }
  }catch{}
});

practiceFilter.addEventListener("change", () => {
  if(gameScreen.style.display !== "none"){
    setMessage("Filter geändert. Starte „Neuer Durchlauf“.", "");
  }
});

/* INIT */
showEditor();
</script>
</body>
</html>
